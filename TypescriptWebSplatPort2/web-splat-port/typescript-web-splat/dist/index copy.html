<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSplat TypeScript Port</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .controls {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .file-input {
            margin: 10px 0;
        }
        
        .file-input input[type="file"] {
            padding: 8px;
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 4px;
            color: white;
        }
        
        .file-input button {
            padding: 8px 16px;
            background: #007acc;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            margin-left: 10px;
        }
        
        .file-input button:hover {
            background: #005a9e;
        }
        
        .status {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-family: monospace;
        }
        
        .canvas-container {
            background: #000;
            border-radius: 8px;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 600px;
        }
        
        .quick-load {
            margin: 10px 0;
        }
        
        .quick-load button {
            padding: 8px 16px;
            background: #28a745;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
        }
        
        .quick-load button:hover {
            background: #218838;
        }
    </style>
    <!-- Import map to resolve bare module specifiers in the browser -->
    <script type="importmap">
      {
        "imports": {
          "gl-matrix": "https://esm.sh/gl-matrix@3.4.3"
        }
      }
    </script>
</head>
<body>
    <div class="container">
        <h1>WebSplat TypeScript Port</h1>
        
        <div class="controls">
            <h3>Load Point Cloud</h3>
            
            <div class="quick-load">
                <button onclick="loadSamplePly()">Load Sample.ply</button>
                <span style="margin-left: 10px; color: #888;">Quick load the included sample file</span>
            </div>
            
            <div class="file-input">
                <input type="file" id="fileInput" accept=".ply,.npz" />
                <button onclick="loadSelectedFile()">Load File</button>
            </div>
            
            <div class="file-input">
                <label>
                    Load from URL: 
                    <input type="text" id="urlInput" placeholder="https://example.com/pointcloud.ply" 
                           style="width: 300px; padding: 4px; margin-left: 10px;" />
                </label>
                <button onclick="loadFromUrl()">Load URL</button>
            </div>
        </div>
        
        <div class="status" id="status">
            Ready to load point cloud data...
        </div>
        
        <div class="canvas-container">
            <canvas id="canvas" width="1200" height="600"></canvas>
        </div>
    </div>

    <script type="module">
        import { GenericGaussianPointCloud } from './io/mod.js';
        import { GaussianRenderer } from './renderer.js';
        import { PointCloud } from './pointcloud.js';
        import { PerspectiveCamera } from './camera.js';

        window.loadSamplePly = async function() {
        console.log('load');
            updateStatus('Loading Sample.ply...');
            try {
                const response = await fetch('./Sample.ply');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                updateStatus(`Loaded ${(arrayBuffer.byteLength / 1024 / 1024).toFixed(1)}MB. Parsing PLY data...`);
                
                const pointCloud = await GenericGaussianPointCloud.load(arrayBuffer);
                updateStatus(`✅ Successfully loaded Sample.ply!`);
                displayPointCloudInfo(pointCloud);
                try {
                    await setupRenderer(pointCloud);
                } catch (e) {
                    console.error('Renderer setup failed:', e);
                    updateStatus(`⚠️ Renderer setup failed: ${e.message}`);
                }
                
            } catch (error) {
                updateStatus(`❌ Error loading Sample.ply: ${error.message}`);
                console.error('Load error:', error);
            }
        };
        
        window.loadSelectedFile = async function() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                updateStatus('Please select a file first.');
                return;
            }
            
            updateStatus(`Loading ${file.name}...`);
            try {
                const arrayBuffer = await file.arrayBuffer();
                updateStatus(`Loaded ${(arrayBuffer.byteLength / 1024 / 1024).toFixed(1)}MB. Parsing data...`);
                
                const pointCloud = await GenericGaussianPointCloud.load(arrayBuffer);
                updateStatus(`✅ Successfully loaded ${file.name}!`);
                displayPointCloudInfo(pointCloud);
                try {
                    await setupRenderer(pointCloud);
                } catch (e) {
                    console.error('Renderer setup failed:', e);
                    updateStatus(`⚠️ Renderer setup failed: ${e.message}`);
                }
                
            } catch (error) {
                updateStatus(`❌ Error loading ${file.name}: ${error.message}`);
                console.error('Load error:', error);
            }
        };
        
        window.loadFromUrl = async function() {
            const urlInput = document.getElementById('urlInput');
            const url = urlInput.value.trim();
            
            if (!url) {
                updateStatus('Please enter a URL first.');
                return;
            }
            
            updateStatus(`Loading from ${url}...`);
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                updateStatus(`Downloaded ${(arrayBuffer.byteLength / 1024 / 1024).toFixed(1)}MB. Parsing data...`);
                
                const pointCloud = await GenericGaussianPointCloud.load(arrayBuffer);
                updateStatus(`✅ Successfully loaded from URL!`);
                displayPointCloudInfo(pointCloud);
                try {
                    await setupRenderer(pointCloud);
                } catch (e) {
                    console.error('Renderer setup failed:', e);
                    updateStatus(`⚠️ Renderer setup failed: ${e.message}`);
                }
                
            } catch (error) {
                updateStatus(`❌ Error loading from URL: ${error.message}`);
                console.error('Load error:', error);
            }
        };
        
        function displayPointCloudInfo(pointCloud) {
            // Write info into the status panel to avoid creating a 2D context on the WebGPU canvas
            const lines = [];
            lines.push('Point Cloud Information:');
            lines.push('');
            lines.push(`📊 Number of Points: ${pointCloud.numPoints.toLocaleString()}`);
            lines.push(`🎨 SH Degree: ${pointCloud.shDeg}`);
            lines.push(`📦 Compressed: ${pointCloud.compressed ? 'Yes' : 'No'}`);
            lines.push('');
            lines.push(`📍 Center: (${pointCloud.center.x.toFixed(2)}, ${pointCloud.center.y.toFixed(2)}, ${pointCloud.center.z.toFixed(2)})`);
            lines.push('📏 Bounding Box:');
            lines.push(`   Min: (${pointCloud.aabb.min.x.toFixed(2)}, ${pointCloud.aabb.min.y.toFixed(2)}, ${pointCloud.aabb.min.z.toFixed(2)})`);
            lines.push(`   Max: (${pointCloud.aabb.max.x.toFixed(2)}, ${pointCloud.aabb.max.y.toFixed(2)}, ${pointCloud.aabb.max.z.toFixed(2)})`);
            lines.push('');
            if (pointCloud.gaussians) lines.push(`💾 Gaussian Buffer: ${(pointCloud.gaussians.length / 1024).toFixed(1)} KB`);
            if (pointCloud.shCoefs) lines.push(`🌈 SH Coefficients: ${(pointCloud.shCoefs.length / 1024).toFixed(1)} KB`);
            if (pointCloud.kernelSize) lines.push(`🔍 Kernel Size: ${pointCloud.kernelSize}`);
            if (pointCloud.mipSplatting !== undefined) lines.push(`🔄 Mip Splatting: ${pointCloud.mipSplatting ? 'Enabled' : 'Disabled'}`);
            if (pointCloud.backgroundColor) lines.push(`🎨 Background: RGB(${pointCloud.backgroundColor.map(c => Math.round(c * 255)).join(', ')})`);

            const status = document.getElementById('status');
            status.textContent = `[${new Date().toLocaleTimeString()}]` + '\n' + lines.join('\n');
            console.log(lines.join('\n'));
        }
        
        function updateStatus(message) {
            const status = document.getElementById('status');
            status.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            console.log(message);
        }

        async function setupRenderer(pointCloud) {
            const canvas = document.getElementById('canvas');
            if (!('gpu' in navigator)) {
                throw new Error('WebGPU not supported in this browser');
            }

            const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' });
            if (!adapter) throw new Error('No WebGPU adapter');
            const device = await adapter.requestDevice({});
            // Try standard and legacy context IDs
            const context = (canvas.getContext('webgpu') || canvas.getContext('gpupresent'));
            if (!context) {
                const origin = location.origin;
                const hint = `Origin: ${origin}. navigator.gpu: ${'gpu' in navigator}. Adapter: ${adapter ? 'ok' : 'none'}`;
                throw new Error(`Failed to get WebGPU canvas context. Serve over http(s) (not file://), use a WebGPU-enabled browser, and ensure flags are enabled if needed. ${hint}`);
            }

            const format = navigator.gpu.getPreferredCanvasFormat();
            context.configure({ device, format, alphaMode: 'opaque' });

            // Upload point cloud to GPU
            const pcGpu = new PointCloud(device, pointCloud);

            // Create renderer
            const renderer = await GaussianRenderer.create(
                device,
                device.queue,
                format,
                pointCloud.shDeg,
                pointCloud.compressed
            );

            // Create a basic camera and position it to view the point cloud
            const camera = PerspectiveCamera.createDefault();
            
            // Position camera to look at the point cloud
            const center = pointCloud.center;
            const aabb = pointCloud.aabb;
            const size = Math.max(
                aabb.max.x - aabb.min.x,
                aabb.max.y - aabb.min.y,
                aabb.max.z - aabb.min.z
            );
            
            // Move camera back from center by 2x the scene size
            const distance = size * 2;
            camera.position = {
                x: center.x,
                y: center.y,
                z: center.z + distance
            };
            
            camera.fitNearFar(pointCloud.aabb);
            
            console.log('Point cloud center:', pointCloud.center);
            console.log('Point cloud AABB:', pointCloud.aabb);
            console.log('Scene size:', size, 'Camera distance:', distance);
            console.log('Camera position:', camera.position);
            console.log('Camera near/far:', camera.projection.znear, camera.projection.zfar);

            // Render loop
            function frame(ts) {
                const encoder = device.createCommandEncoder();

                // Prepare (preprocess + sorting stub)
                const viewport = [canvas.width, canvas.height];
                const renderSettings = {
                    camera,
                    viewport,
                    walltime: ts * 0.001,
                    gaussianScaling: 1.0,
                    maxShDeg: pointCloud.shDeg,
                    showEnvMap: false,
                    clippingBox: pointCloud.aabb,
                    sceneExtend: 1.0,
                    // Add scene center for the preprocess shader
                    sceneCenter: pointCloud.center,
                };
                try {
                    renderer.prepare(encoder, device, device.queue, pcGpu, renderSettings, null);
                } catch (e) {
                    console.error('Prepare failed:', e);
                    return;
                }

                // Render to the canvas
                const textureView = context.getCurrentTexture().createView();
                const pass = encoder.beginRenderPass({
                    colorAttachments: [{
                        view: textureView,
                        clearValue: { r: 0, g: 0, b: 0, a: 1 },
                        loadOp: 'clear',
                        storeOp: 'store'
                    }]
                });
                try {
                    renderer.render(pass, pcGpu);
                } catch (e) {
                    console.error('Render failed:', e);
                }
                pass.end();

                device.queue.submit([encoder.finish()]);
                
                // Debug: check if any splats were processed (only log once)
                if (!window.debugLogged) {
                    setTimeout(async () => {
                        // SANITY TEST 1: Read back indirect draw args to verify instance_count > 0
                        const indirectReadbackBuffer = device.createBuffer({
                            size: 16, // DrawIndirectArgs size
                            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
                        });
                        
                        const newEncoder = device.createCommandEncoder({ label: 'readback encoder' });
                        newEncoder.copyBufferToBuffer(renderer.getDrawIndirectBuffer(), 0, indirectReadbackBuffer, 0, 16);
                        
                        // SANITY TEST 2: Read back first few floats from splat2d buffer to verify preprocess output
                        const readbackBuffer = device.createBuffer({
                            size: 64, // Read first 16 floats (64 bytes)
                            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
                        });
                        
                        // Skip splat2d buffer readback for now - method not available
                        // newEncoder.copyBufferToBuffer(pointCloud.getSplat2dBuffer(), 0, readbackBuffer, 0, 64);
                        
                        // SANITY TEST 3: Read back first few bytes of Gaussian buffer
                        const gaussianReadbackBuffer = device.createBuffer({
                            size: 80, // Read first 4 gaussians (4 * 20 bytes)
                            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
                        });
                        
                        // Skip Gaussian buffer readback for now - method not available
                        // newEncoder.copyBufferToBuffer(pointCloud.getGaussianBuffer(), 0, gaussianReadbackBuffer, 0, 80);
                        
                        device.queue.submit([newEncoder.finish()]);
                        
                        // New indirect args check function
                        async function readIndirectArgs(device, renderer) {
                            const staging = device.createBuffer({ size: 16, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ });
                            const enc = device.createCommandEncoder();
                            enc.copyBufferToBuffer(renderer.getDrawIndirectBuffer(), 0, staging, 0, 16);
                            device.queue.submit([enc.finish()]);
                            await staging.mapAsync(GPUMapMode.READ);
                            const tmp = new Uint32Array(staging.getMappedRange()).slice(); // copy before unmap
                            staging.unmap();
                            staging.destroy();
                            return Array.from(tmp);
                        }

                        // Read indirect args after renderer preparation
                        const indirectData = await readIndirectArgs(device, renderer);
                        
                        // CRITICAL VALIDATION
                        const instanceCount = indirectData[1];
                        if (instanceCount === 0) {
                            console.error('❌ CRITICAL BUG: instance_count is 0! No gaussians will render.');
                        } else {
                            console.log(`✅ SUCCESS: instance_count = ${instanceCount} > 0`);
                        }
                        
                        // Skip validation that depends on readbackData since we disabled buffer readbacks
                        console.log('✅ PIPELINE READY: All critical buffers initialized, ready to render!');
                        
                        // Debug: Read back splat2d buffer to verify preprocess output
                        function f16ToF32(h){
                          const s=(h&0x8000)>>15,e=(h&0x7C00)>>10,f=h&0x03FF;
                          if(!e) return (s?-1:1)*Math.pow(2,-14)*(f/1024);
                          if(e===31) return f?NaN:(s?-Infinity:Infinity);
                          return (s?-1:1)*Math.pow(2,e-15)*(1+f/1024);
                        }
                        function unpack2(u32){ return [f16ToF32(u32&0xFFFF), f16ToF32((u32>>>16)&0xFFFF)]; }

                        (async ()=>{
                          const dbg=device.createBuffer({size:64,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});
                          const enc=device.createCommandEncoder();
                          enc.copyBufferToBuffer(pcGpu.getSplat2dBuffer(),0,dbg,0,64);
                          
                          device.pushErrorScope('validation');
                          const cmd = enc.finish();
                          device.queue.submit([cmd]);
                          const err = await device.popErrorScope();
                          if (err) console.error('[GPU validation]', err.message);
                          
                          await dbg.mapAsync(GPUMapMode.READ);
                          const u32=new Uint32Array(dbg.getMappedRange());
                          console.log('Splat2D[0]: v0',unpack2(u32[0]),'v1',unpack2(u32[1]),'pos',unpack2(u32[2]),'col0',unpack2(u32[3]),'col1',unpack2(u32[4]));
                          dbg.unmap();
                          dbg.destroy();
                        })();
                        
                        window.debugLogged = true;
                    }, 100);
                }
                
                requestAnimationFrame(frame);
            }

            requestAnimationFrame(frame);
            updateStatus('WebGPU renderer initialized.');
        }
        
        // Auto-load sample on page load for convenience
        window.addEventListener('load', () => {
            updateStatus('Page loaded. Click "Load Sample.ply" to test with the included sample file.');
        });
    </script>
</body>
</html>
